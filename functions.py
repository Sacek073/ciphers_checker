import subprocess
import requests
import os
from prettytable import PrettyTable
from ansicolors import *
import xml.etree.ElementTree as ET

# Windows
# SSLSCANPATH = "C:\\Users\\klusacekj\\Documents\\Tools\\sslscan-2.1.4\\sslscan.exe"
# Linux
SSLSCANPATH = "sslscan"


def get_ciphers_nmap(domain, port):
    """
    Run nmap to get the ciphers used in the domain and port
    Output is saved in a file tmp_{domain}_{port}.xml and also returned as a string
    """
    cmd = f"nmap -oX tmp_{domain}_{port}.xml -p {port} -Pn --script ssl-enum-ciphers,ssl-cert {domain}"
    print(f"Running nmap for host: {domain} on port: {port}")
    output = subprocess.check_output(cmd, shell=True, universal_newlines=True)
    return output

def get_results_sslscan(domain, port):
    """
    Run sslscan in order to get info about SSLv2, SSLv3 and TLS Compression
    """
    cmd = f"{SSLSCANPATH} --xml=tmp_sslscan_{domain}_{port}.xml {domain}:{port}"
    print(f"Running sslscan for host: {domain} on port: {port}")
    output = subprocess.check_output(cmd, shell=True, universal_newlines=True)
    return output


def parse_ciphers(domain=None, port=None, file=None):
    """
    Function parses the xml file generated by nmap and returns the ciphers used
    """
    root = get_xml_root(domain, port, file)
    ciphers_tables = root.findall(".//table[@key='ciphers']")
    nmap_output = root.find(".//script[@id='ssl-enum-ciphers']").get("output")

    required_keys = {"kex_info", "name", "strength"}
    ciphers = {}

    for table in ciphers_tables:
        for cipher in table.findall("table"):
            elem_dict = {elem.get("key"): elem.text for elem in cipher.findall("elem")}
            if required_keys.issubset(elem_dict.keys()):  # Check if it is cipher
                kex_info = elem_dict["kex_info"]
                cipher_name = elem_dict["name"]
                # strength = elem_dict["strength"]

                ciphers[cipher_name] = [kex_info]

            else:
                # Element is not cipher
                pass

    # Adding TLS version info to each cipher
    nmap_output = nmap_output.split("\n")
    current_TLS = None
    for line in nmap_output:
        if "TLSv" in line:
            # First get the TLS version from the file
            # Versions are sequential and each version is followed by the ciphers that support that version
            current_TLS = line.strip()[:-1]
        if "TLS_" in line:
            # If this condition is met, the current line represents info about particular cipher
            # We know, in which TLS version we are, so we simply add the version in the ciphers dictionary
            cipher = line.strip().split(" ")[0]
            ciphers[cipher].append(current_TLS)

    return ciphers


def remove_tmp_files(domain, port):
    """
    Removes tmp file generated by nmap
    """
    try:
        os.remove(f"tmp_{domain}_{port}.xml")
        os.remove(f"tmp_sslscan_{domain}_{port}.xml")
    except:
        pass


def remove_ake_with(string):
    if "_AKE_WITH_" in string:
        return string.replace("_AKE_WITH_", "_")
    else:
        return string


def get_stats(cipher):
    """
    Function returns the stats of a cipher, using the ciphersuite.info API
    """
    # TLS 1.3 ciphers have different naming convention in ciphersuite.info
    url = f"https://ciphersuite.info/api/cs/{remove_ake_with(cipher)}"

    payload = {}
    headers = {
    'Accept': 'application/json'
    }

    response = requests.request("GET", url, headers=headers, data=payload)
    data = response.json()
    # If the naming convention was changed, we need to change it back
    data[cipher] = data.pop(remove_ake_with(cipher))

    return data


def print_table(results):
    """
    Function prints the results in a table
    """
    print("Overview of the used ciphers (ciphersuite.info):")
    table = PrettyTable()
    table.field_names = ["Cipher", "Security", "TLS", "URL"]
    for key, value in results.items():
        stats = value.get("stats")
        tls_versions = [tls_color(float(tls[4:])) for tls in value.get('tls')]

        # We need to nemove the _AKE_WITH_ from the cipher name in orde to have functional URL
        table.add_row([key, security_color(stats.get('security')), ",".join(tls_versions), f"https://ciphersuite.info/cs/{remove_ake_with(key)}"])

    table.align["Cipher"] = "l"
    table.align["URL"] = "l"
    print(table)


def tls_color(version):
    """
    Adds colors to output based on the TLS version
    """
    if version < 1.1: # TODO nastavit sprÃ¡vnou hodnotu
        return f"{RED}{str(version)}{RESET}"
    elif version < 1.2:
        return f"{YELLOW}{str(version)}{RESET}"
    else:
        return f"{str(version)}"

def security_color(word):
    """
    Adds colors to output based on the security of the cipher
    Colors are coresponing to the security level on the web version of ciphersuite.info
    """
    if word == "secure":
        return f"{LIGHT_GREEN}{word}{RESET}"
    elif word == "recommended":
        return f"{GREEN}{word}{RESET}"
    elif word == "weak":
        return f"{YELLOW}{word}{RESET}"
    elif word == "insecure":
        return f"{RED}{word}{RESET}"
    else:
        return word


def get_xml_root(domain=None, port=None, file=None):
    if file:
        tree = ET.parse(file)
    elif domain and port:
        tree = ET.parse(f"tmp_{domain}_{port}.xml")
    else:
        print("No file or domain and port specified for openig xml file, exitting...")
        exit(1)

    return tree.getroot()
